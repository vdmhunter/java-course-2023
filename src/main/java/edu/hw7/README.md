# Домашнее задание №7

## Задание 1
Напишите программу, в которой несколько потоков увеличивают общий счетчик на 1.

Напишите тесты: убедитесь, что счетчик потокобезопасен и использует классы Atomic для исключения состояния гонки.


## Задание 2
Реализуйте функцию, которая вычисляет факториал числа в многопоточном режиме при помощи parallelStream.


## Задание 3
Мы пишем специальный кэширующий сервис для поиска людей по атрибутам:

    public record Person(int id, String name, String address, String phoneNumber) {}
    
    interface PersonDatabase {
        void add(Person person);
        void delete(int id);
    
        @Nullable Person findByName(String name);
        @Nullable Person findByAddress(String address);
        @Nullable Person findByPhone(String phone);
    }

Сервис должен позволять найти человека только тогда, когда он стал доступен для поиска по любому из атрибутов, то есть невозможна ситуация, когда человека с id=3 можно найти по имени, но нельзя по телефону.

Реализуйте задачу при помощи synchronized.

##### Задание 3.5
В задачах кэширования часто есть дисбаланс между количеством чтений и записи.

Добавьте решение для предыдущей задачи на основе ReadWriteLock.


## Задание 4
Реализуйте расчет числа Пи, используя метод Монте-Карло и несколько потоков.

Онлайн-демо: https://demonstrations.wolfram.com/ApproximatingPiByTheMonteCarloMethod.

Реализуйте сначала однопоточную версию, а затем многопоточную.

В ответе текстом приведите среднее время ускорения решения в зависимости от количества потоков, а так же уровень погрешности для симуляции в 10тыс, 100тыс, 1млн и 10млн симуляций.

Однопоточный алгоритм решения задачи:
1. Заведите переменные для подсчета общего числа точек (totalCount) и числа точек, попавших в круг (circleCount)
2. Сделайте цикл на N итераций (значение конфигурируется), чем больше итераций вы сделаете, тем точнее будет приближение:
   * создайте случайную точку в квадрате
   * проверьте, находится ли точка внутри круга радиусом 1 с центром в точке (0.5, 0.5), если точка внутри круга, увеличиваем circleCount
   * увеличиваем totalCount
3. Вычислите приближение числа Пи как 4 * (circleCount / totalCount)
